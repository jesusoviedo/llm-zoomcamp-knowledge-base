# Workshop 1 - De REST al razonamiento con DLT y Cognee

Este documento recopila mis apuntes y recursos para la **Workshop 1** del curso LLM Zoomcamp.

## üìö Recursos del Workshop

- **Video del Workshop**: [Ver en YouTube](https://www.youtube.com/watch?v=MNt_KK32gys)
- **Diapositivas utilizadas**: [Ver en Google Slides](https://docs.google.com/presentation/d/1oHQilxEVqGGW4S2ctNEE0wHY2LgcjYLaRUziAoinsis/edit?usp=sharing)
- **Notebook en Google Colab**: [Abrir en Colab](https://colab.research.google.com/drive/1vBA9OIGChcKjjg8r5hHduR0v3A5D6rmH?usp=sharing#scrollTo=ZU45VaNNG970)

## üìù Notas de la teor√≠a

### ¬øQu√© es dlt?

**dlt (data load tool)** es una biblioteca de Python de c√≥digo abierto, declarativa y centrada en el desarrollador, dise√±ada para **simplificar y automatizar la creaci√≥n de pipelines de datos**. Su filosof√≠a se basa en la convenci√≥n sobre configuraci√≥n, permitiendo enfocarse en el *qu√©* y no en el *c√≥mo*.

#### **Principales ventajas**

- Inferencia autom√°tica de esquemas y su evoluci√≥n
- Carga incremental sin configuraci√≥n adicional
- M√≠nima configuraci√≥n y sin necesidad de backend
- Ejecutable en notebooks, scripts, AWS Lambda, Airflow y m√°s
- Compatible con m√∫ltiples fuentes y destinos de datos


#### **Proceso dlt: ETL Automatizado**

1. Extract

- Conectores listos para usar (APIs REST, bases SQL, almacenamiento en la nube, estructuras Python)
- Gesti√≥n autom√°tica de paginaci√≥n, autenticaci√≥n y control de flujo

2. Transform and Normalize

- Limpieza y normalizaci√≥n autom√°tica de datos semi-estructurados (como JSON)
- Inferencia y evoluci√≥n de esquemas sin intervenci√≥n manual
- Generaci√≥n autom√°tica de tablas secundarias y relaciones

3. Load

- Carga eficiente y en lote hacia destinos como:
  - DuckDB, BigQuery, Snowflake, Redshift, Databricks y m√°s
- Optimizaciones para grandes vol√∫menes de datos


#### **¬øQu√© ocurre al ejecutar `pipeline.run()`?**

1. Gesti√≥n de Estado

- Registra ejecuciones anteriores, versiones de esquema, archivos procesados y progresos (ej. timestamps)
- Estado persistente almacenado en el destino, asegurando continuidad y tolerancia a fallos

2. Carga Incremental

- Solo se cargan los datos nuevos o modificados desde la √∫ltima ejecuci√≥n
- Reducci√≥n significativa en tiempo, costos y consumo de APIs

3. Escalabilidad y Paralelizaci√≥n

- Procesamiento por fragmentos (chunks) sin saturar la memoria
- Creaci√≥n impl√≠cita de un DAG de extracci√≥n
- Ejecuci√≥n en paralelo de tareas independientes

### ¬øQu√© es Retrieval-Augmented Generation (RAG)?

**RAG** es un enfoque que combina modelos de lenguaje (LLMs) con bases de conocimiento externas, permiti√©ndoles consultar datos din√°micamente en tiempo real.

#### **Objetivos de RAG**:

- **Reducir alucinaciones**: Respuestas basadas en hechos verificables.
- **Incluir conocimiento actualizado y espec√≠fico del dominio**.
- **Aumentar la transparencia**: Capacidad de citar fuentes utilizadas.

#### **Flujo Offline: Preparaci√≥n del Conocimiento**

Proceso previo a recibir preguntas de usuarios. Se construye una base de datos vectorial a partir de documentos crudos.

Etapas:
1. **Load** ‚Äì Se usan *Document Loaders* para cargar documentos desde PDFs, webs, bases de datos, etc.
2. **Split** ‚Äì Los documentos se dividen en *chunks* peque√±os para ajustarse al contexto limitado del LLM.
3. **Embed** ‚Äì Cada chunk se convierte en un vector usando modelos de embeddings (OpenAI, Cohere, etc.).
4. **Store** ‚Äì Los vectores y su texto original se almacenan en bases vectoriales como Qdrant o ChromaDB.

#### **Flujo Online: Generaci√≥n en Tiempo Real**

Se activa cuando un usuario realiza una pregunta. Se recupera informaci√≥n relevante y se genera una respuesta fundamentada.

Etapas:
1. **Retrieve** ‚Äì La pregunta se vectoriza y se buscan los chunks m√°s cercanos en la base vectorial.
2. **Augment** ‚Äì Se crea un *prompt aumentado* que incluye la pregunta y los chunks recuperados.
3. **Generate** ‚Äì El LLM responde usando este prompt enriquecido con contexto f√°ctico.

#### **Limitaci√≥n: Compresi√≥n con P√©rdidas**

El paso de *chunking* puede romper la coherencia entre conceptos relacionados distribuidos en distintas partes del documento.

Ejemplo de Problema:

- Un concepto clave (T√©rmino A) aparece en la p√°gina 1.
- Su aplicaci√≥n (Ejemplo B) aparece en la p√°gina 10.
- RAG puede recuperar solo uno de los dos chunks, generando respuestas incompletas.

### ¬øQu√© es Cognee?

**Cognee** es un framework de c√≥digo abierto para agentes de IA que va m√°s all√° de la b√∫squeda por similitud. Su objetivo es construir una **memoria sem√°ntica evolutiva**, modelando activamente las relaciones entre conceptos mediante grafos de conocimiento y pipelines de datos automatizados.

#### **Pipeline ECL: Extract, Cognify, Load**

Una nueva alternativa al cl√°sico ETL y al flujo de RAG.

1. Extract

- Ingesta de m√∫ltiples fuentes (documentos, bases de datos, transcripciones).
- Utiliza frameworks como `dlt` para conectar m√°s de 28 tipos de fuentes.

2. Cognify

- Paso clave del framework.
- Construye una representaci√≥n dual:
  - **Grafo de conocimiento** (con nodos y relaciones)
  - **√çndice vectorial** para b√∫squeda sem√°ntica
- Detecta entidades, relaciones y dependencias.
- Transforma documentos en mapas conceptuales interactivos.

3. Load

- Persistencia flexible en:
  - Bases de datos vectoriales (Qdrant, Weaviate, etc.)
  - Bases de datos gr√°ficas (Neo4j, NetworkX, etc.)

#### **Ventajas Clave de Cognee**

- **Contexto relacional profundo**: Recupera subgrafos completos, no solo chunks aislados.
- **Razonamiento real**: Permite inferencias l√≥gicas sobre la estructura del conocimiento.
- **Ontolog√≠as personalizadas**: Define esquemas sem√°nticos espec√≠ficos del dominio.
- **Control y privacidad**: Desplegable 100% on-premise.

#### **Casos de Uso**

1. **Asistentes de Programaci√≥n**  
   - Navega y analiza dependencias en bases de c√≥digo complejas.
2. **Chatbots Avanzados y Soporte Contextual**  
   - Construye perfiles de usuario din√°micos basados en historial y preferencias.
3. **Gesti√≥n del Conocimiento y Recursos Humanos**  
   - Extrae respuestas complejas desde grandes vol√∫menes de texto no estructurado.

#### **GraphRAG**

Cognee se alinea con la tendencia de GraphRAG.

### ¬øQu√© son las Bases de Datos Gr√°ficas?

Son sistemas de almacenamiento dise√±ados espec√≠ficamente para **modelar, persistir y consultar relaciones complejas**. A diferencia de las bases relacionales (tablas), las gr√°ficas se estructuran como redes de entidades conectadas.

#### **Modelo de Grafo de Propiedades**

- **Nodos**: Representan entidades (Persona, Empresa, Funci√≥n, etc.)
- **Relaciones**: Conectan nodos, con direcci√≥n y tipo (ej. `LLAMA_A`, `CONOCE`)
- **Propiedades**: Atributos en nodos o relaciones (ej. `nombre: "Alice"`, `desde: 2021`)

Las relaciones son elementos persistentes, no c√°lculos temporales como en los `JOINs` de SQL.

#### **Comparativa: Ventajas y Desventajas**

Ventajas

- **Alto rendimiento** en consultas de m√∫ltiples saltos (traversals)
- **Flexibilidad del esquema** sin migraciones complejas
- **Modelado intuitivo**, alineado con la l√≥gica humana

Desventajas

- **No reemplazan** las bases tradicionales para consultas tabulares masivas
- **Falta de estandarizaci√≥n total** en lenguajes (aunque Cypher es popular)
- **Gesti√≥n compleja** en grafos muy densos o con "supernodos"

#### **Casos de Uso m√°s all√° de RAG**

1. **Detecci√≥n de Fraude**  
   Modelan redes de transacciones, usuarios, IPs y dispositivos para identificar patrones complejos en tiempo real.
2. **Motores de Recomendaci√≥n**  
   Basados en interacciones entre usuarios, productos y preferencias.
3. **Gesti√≥n de Redes de TI**  
   Analizan las dependencias entre servidores, routers y servicios para diagn√≥stico y resiliencia.
4. **Redes Sociales y Grafos de Conocimiento**  
   Usados para an√°lisis de comunidades, propagaci√≥n de informaci√≥n e inferencias sem√°nticas.


#### **Relevancia para IA Cognitiva**

Las bases gr√°ficas son fundamentales para frameworks como **Cognee**, ya que permiten:

- Representar relaciones expl√≠citas entre conceptos
- Recuperar subgrafos como contexto relacional
- Aplicar razonamiento l√≥gico sobre entidades conectadas

Las bases gr√°ficas no solo almacenan datos, **modelan el conocimiento** en su forma m√°s natural y navegable.

### ¬øQu√© es K√πzu?

K√πzu es una base de datos de grafos **open source**, embebida, de alto rendimiento, dise√±ada para tareas anal√≠ticas (OLAP). Su filosof√≠a es similar a la de SQLite, pero en el mundo de los grafos: se ejecuta como una **biblioteca local**, sin servidores ni configuraci√≥n adicional.

#### **Ventajas Clave**

- **Embebido**: se integra directamente como librer√≠a en tu aplicaci√≥n Python (`pip install kuzu`)
- **Optimizado para OLAP**: motor columnar + ejecuci√≥n vectorizada = consultas anal√≠ticas r√°pidas
- **Integraci√≥n con ecosistema Python**: soporta Pandas, Polars, DuckDB, Parquet y Arrow
- **Modelo estructurado**: define tablas de nodos y relaciones con tipos, facilitando optimizaciones


### ¬øQu√© es Neo4j?

Neo4j es una base de datos gr√°fica **nativa, madura y empresarial**, orientada tanto a cargas de trabajo anal√≠ticas (OLAP) como transaccionales (OLTP). Se presenta como una **plataforma completa** para modelar, almacenar y consultar relaciones complejas en entornos de producci√≥n.

#### **Ventajas Clave**

- **Soporte para OLTP y OLAP**  
- **ACID-compliance** para aplicaciones cr√≠ticas  
- **Escalabilidad empresarial** (cl√∫steres, alta disponibilidad)  
- **Graph Data Science (GDS)**: algoritmos de grafos integrados  
- **Comunidad y soporte extensos** (GraphAcademy, documentaci√≥n, partners)  




## üõ†Ô∏è Ejemplo pr√°ctico de Qdrant

### Creaci√≥n de un entorno de desarrollo

Para crear y gestionar el entorno de Python de este proyecto se utiliza `uv`, una herramienta moderna que combina la gesti√≥n de entornos virtuales y la resoluci√≥n de dependencias de forma r√°pida y eficiente.

Este enfoque reemplaza el uso tradicional de herramientas como `venv`, `pip` y `virtualenv`, ofreciendo una experiencia m√°s simple y √°gil.

‚ÑπÔ∏è Para m√°s detalles sobre c√≥mo instalar y utilizar uv, consulta el archivo [`working-with-uv.md`](../docs/working-with-uv.md)

Una vez instalado `uv`, puedes crear el entorno virtual e instalar todas las dependencias necesarias con un solo comando:

```bash
uv venv && uv sync
```

Este comando crear√° un entorno virtual en el directorio del proyecto y sincronizar√° las librer√≠as especificadas en el archivo `pyproject.toml`.

### Interactuando con Qdrant usando Python

#### **1. Descargar la imagen de Qdrant desde Docker Hub**

```bash
docker pull qdrant/qdrant
```

#### **2. Ejecutar el servicio**

```bash
docker run -p 6333:6333 -p 6334:6334 \
    -v "$(pwd)/qdrant_storage:/qdrant/storage:z" \
    qdrant/qdrant
```

Con esta configuraci√≥n predeterminada, todos los datos se almacenar√°n en el directorio  `./qdrant_storage`, el cual ser√° accesible tanto para el contenedor como para el host.

Qdrant ahora estar√° disponible en:
- API REST: http://localhost:6333
- Interfaz web: http://localhost:6333/dashboard
- API gRPC: http://localhost:6334

#### **3. Flujo b√°sico**

Si deseas ver un ejemplo pr√°ctico de c√≥mo crear una colecci√≥n, agregar elementos y realizar una consulta, puedes consultar el archivo [`0_quickstart`](./notebook/0_quickstart.ipynb).

Este notebook incluye ejemplos de:
- Creaci√≥n de un cliente.
- Creaci√≥n de una colecci√≥n.
- Inserci√≥n de puntos/vectores en una colecci√≥n.
- Recuperaci√≥n de los puntos/vectores m√°s cercanos.
- Aplicaci√≥n de filtros en las b√∫squedas.

#### **4. Generaci√≥n de incrustaciones (embeddings) con FastEmbed**

Si deseas ver un ejemplo pr√°ctico de c√≥mo generar incrustaciones de texto utilizando la librer√≠a `FastEmbed`, puedes consultar el archivo [`1_fastembed_embeddings`](./notebook/1_fastembed_embeddings.ipynb).

Este notebook incluye ejemplos de:
- Instalaci√≥n y carga del modelo de incrustaci√≥n (`BAAI/bge-small-en-v1.5`, entre otros).
- Transformaci√≥n de textos en vectores num√©ricos (embeddings).
- Visualizaci√≥n de las incrustaciones generadas.
- Preparaci√≥n de los vectores para su posterior indexaci√≥n en una colecci√≥n de Qdrant.

#### **5. B√∫squeda sem√°ntica con Qdrant**

Si deseas ver un ejemplo pr√°ctico de c√≥mo realizar una b√∫squeda sem√°ntica utilizando Qdrant, puedes consultar el archivo [`2_sematic_search.ipynb`](./notebook/2_sematic_search.ipynb).

Este notebook incluye ejemplos de:
- Creaci√≥n de una colecci√≥n en Qdrant para b√∫squeda sem√°ntica.
- Inserci√≥n de vectores densos generados previamente.
- Ejecuci√≥n de b√∫squedas basadas en similitud sem√°ntica.
- Interpretaci√≥n de los resultados obtenidos en consultas de lenguaje natural.

#### **6. Construcci√≥n de un sistema RAG con Qdrant**

Si deseas ver c√≥mo construir un sistema RAG (Retrieval-Augmented Generation) b√°sico, puedes consultar el archivo [`3_rag_and_qdrant.ipynb`](./notebook/3_rag_and_qdrant.ipynb).

Este notebook incluye ejemplos de:
- Indexaci√≥n de documentos con metadatos relevantes.
- Implementaci√≥n de un flujo de recuperaci√≥n y generaci√≥n con OpenAI.
- Uso de Qdrant como backend para la recuperaci√≥n sem√°ntica.
- Generaci√≥n de respuestas fundamentadas en los documentos cargados.

#### **7. B√∫squeda h√≠brida: combinaci√≥n de vectores densos y dispersos**

Si deseas ver c√≥mo realizar una b√∫squeda h√≠brida combinando embeddings densos y vectores dispersos (como BM25), puedes consultar el archivo [`4_hybrid_search.ipynb`](./notebook/4_hybrid_search.ipynb).

Este notebook incluye ejemplos de:
- Configuraci√≥n de una colecci√≥n h√≠brida en Qdrant.
- Inserci√≥n de puntos con vectores densos y texto para vectorizaci√≥n dispersa.
- Ejecuci√≥n de b√∫squedas h√≠bridas con fusi√≥n de puntuaciones.
- Comparaci√≥n entre resultados sem√°nticos, l√©xicos e h√≠bridos.

#### **8. Sistema RAG h√≠brido: recuperaci√≥n y generaci√≥n con Qdrant y OpenAI**
Si deseas ver un ejemplo pr√°ctico de c√≥mo construir un sistema RAG (Retrieval-Augmented Generation) que combine b√∫squeda h√≠brida y generaci√≥n de lenguaje, puedes consultar el archivo [`5_rag_and_qdrant-hybrid_search.ipynb`](./notebook/5_rag_and_qdrant-hybrid_search.ipynb).

Este notebook incluye ejemplos de:
- Preparaci√≥n de una colecci√≥n h√≠brida con Qdrant a partir de un dataset de pel√≠culas.
- Ejecuci√≥n de b√∫squedas h√≠bridas usando fusi√≥n RRF con vectores densos y dispersos.
- Construcci√≥n din√°mica de prompts con resultados recuperados.
- Generaci√≥n de respuestas en lenguaje natural usando un modelo de OpenAI.

## üîó Lectura recomendada
Recomendado para profundizar en los conceptos clave y ampliar tu comprensi√≥n

* [dlt - Getting started](https://dlthub.com/docs/intro)
* [dlt - Sourcest](https://dlthub.com/docs/dlt-ecosystem/verified-sources/)
* [dlt - Destinations](https://dlthub.com/docs/dlt-ecosystem/destinations/)
* [dlt - Qdrant destination](https://dlthub.com/docs/dlt-ecosystem/destinations/qdrant)
* [dlt - Code examples](https://dlthub.com/docs/examples)
* [dlt - Using dlt](https://dlthub.com/docs/general-usage)

* [Cognee - Quickstart](https://docs.cognee.ai/quickstart)
* [Cognee - Hello cognee SDK](https://docs.cognee.ai/tutorials/hello-cognee)
* [Cognee - Core Concepts](https://docs.cognee.ai/core-concepts)
* [Cognee - How-to Guides](https://docs.cognee.ai/how-to-guides)
* [Cognee - Colab Notebooks](https://docs.cognee.ai/reference/colab-notebooks)
* [Cognee - Cognee UI](https://docs.cognee.ai/how-to-guides/cognee-ui)

* [Kuzu - Documentation](https://docs.kuzudb.com/)
* [Kuzu - Create your first graph](https://docs.kuzudb.com/get-started/)
* [Kuzu - Python Tutorial: Analyze a Social Network](https://docs.kuzudb.com/tutorials/python/)
* [Kuzu - Python API](https://docs.kuzudb.com/client-apis/python/)
* [Kuzu - Import data](https://docs.kuzudb.com/import/)

* [Cypher - Tutorial](https://docs.kuzudb.com/tutorials/cypher/)
* [Cypher - Manual](https://docs.kuzudb.com/cypher/)
* [Cypher - Run prepared Cypher statements](https://docs.kuzudb.com/get-started/prepared-statements/)
* [Cypher - What is Cypher](https://neo4j.com/docs/getting-started/cypher/)
* [Cypher - Cheat Sheet](https://neo4j.com/docs/cypher-cheat-sheet/5/all/)

* [Neo4j - What is Neo4j?](https://neo4j.com/docs/getting-started/whats-neo4j/)
* [Neo4j - What is a graph database](https://neo4j.com/docs/getting-started/graph-database/)
* [Neo4j - Graph database concepts](https://neo4j.com/docs/getting-started/appendix/graphdb-concepts/)
* [Neo4j - Build applications with Neo4j and Python](https://neo4j.com/docs/python-manual/current/)
* [Neo4j - Neo4j Movies Application](https://github.com/neo4j-examples/movies-python-bolt)
* [Neo4j - The Neo4j Graph Data Science Library Manualxt](https://neo4j.com/docs/graph-data-science/current/)



## ‚ñ∂Ô∏è Videos recomendados
Selecci√≥n de videos para reforzar visualmente los temas abordados
* [What Is A Graph Database? Common features of graph DBMSs.](https://www.youtube.com/watch?v=BksVyv5864k)
* [Cognee GraphRAG + Visualization](https://www.youtube.com/watch?v=1bezuvLwJmw)
* [Host Your Own Local LLM with Ollama & cognee](https://www.youtube.com/watch?v=aZYRo-eXDzA)



## üìö Cursos adicionales recomendados
Recursos complementarios para seguir aprendiendo y fortaleciendo tus habilidades.

* [Graph Data Modeling Fundamentals](https://graphacademy.neo4j.com/courses/modeling-fundamentals/?category=beginners)
* [Cypher Fundamentals](https://graphacademy.neo4j.com/courses/cypher-fundamentals/?category=beginners)
* [Neo4j Fundamentals](https://graphacademy.neo4j.com/courses/neo4j-fundamentals/?category=beginners)
* [Neo4j & GenerativeAI Fundamentals](https://graphacademy.neo4j.com/courses/genai-fundamentals/?category=development)
* [Using Neo4j with Python](https://graphacademy.neo4j.com/courses/drivers-python/?category=development)
* [Build a Neo4j-backed Chatbot using Python](https://graphacademy.neo4j.com/courses/llm-chatbot-python/?category=development)

---

> üìå **Nota:** este repositorio complementa el curso **LLM Zoomcamp** de [DataTalks.Club](https://datatalks.club/), y contiene notas, lecturas, videos, ejemplos y recursos adicionales.  
> Para acceder al contenido oficial del curso, visita el [**repositorio principal en GitHub**](https://github.com/DataTalksClub/llm-zoomcamp).
