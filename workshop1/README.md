# Workshop 1 - De REST al razonamiento con DLT y Cognee

Este documento recopila mis apuntes y recursos para la **Workshop 1** del curso LLM Zoomcamp.

## üìö Recursos del Workshop

- **Video del Workshop**: [Ver en YouTube](https://www.youtube.com/watch?v=MNt_KK32gys)
- **Diapositivas utilizadas**: [Ver en Google Slides](https://docs.google.com/presentation/d/1oHQilxEVqGGW4S2ctNEE0wHY2LgcjYLaRUziAoinsis/edit?usp=sharing)
- **Notebook en Google Colab**: [Abrir en Colab](https://colab.research.google.com/drive/1vBA9OIGChcKjjg8r5hHduR0v3A5D6rmH?usp=sharing#scrollTo=ZU45VaNNG970)

## üìù Notas de la teor√≠a

### ¬øQu√© es dlt?

**dlt (data load tool)** es una biblioteca de Python de c√≥digo abierto, declarativa y centrada en el desarrollador, dise√±ada para **simplificar y automatizar la creaci√≥n de pipelines de datos**. Su filosof√≠a se basa en la convenci√≥n sobre configuraci√≥n, permitiendo enfocarse en el *qu√©* y no en el *c√≥mo*.

#### **Principales ventajas**

- Inferencia autom√°tica de esquemas y su evoluci√≥n
- Carga incremental sin configuraci√≥n adicional
- M√≠nima configuraci√≥n y sin necesidad de backend
- Ejecutable en notebooks, scripts, AWS Lambda, Airflow y m√°s
- Compatible con m√∫ltiples fuentes y destinos de datos


#### **Proceso dlt: ETL Automatizado**

1. Extract

- Conectores listos para usar (APIs REST, bases SQL, almacenamiento en la nube, estructuras Python)
- Gesti√≥n autom√°tica de paginaci√≥n, autenticaci√≥n y control de flujo

2. Transform and Normalize

- Limpieza y normalizaci√≥n autom√°tica de datos semi-estructurados (como JSON)
- Inferencia y evoluci√≥n de esquemas sin intervenci√≥n manual
- Generaci√≥n autom√°tica de tablas secundarias y relaciones

3. Load

- Carga eficiente y en lote hacia destinos como:
  - DuckDB, BigQuery, Snowflake, Redshift, Databricks y m√°s
- Optimizaciones para grandes vol√∫menes de datos


#### **¬øQu√© ocurre al ejecutar `pipeline.run()`?**

1. Gesti√≥n de Estado

- Registra ejecuciones anteriores, versiones de esquema, archivos procesados y progresos (ej. timestamps)
- Estado persistente almacenado en el destino, asegurando continuidad y tolerancia a fallos

2. Carga Incremental

- Solo se cargan los datos nuevos o modificados desde la √∫ltima ejecuci√≥n
- Reducci√≥n significativa en tiempo, costos y consumo de APIs

3. Escalabilidad y Paralelizaci√≥n

- Procesamiento por fragmentos (chunks) sin saturar la memoria
- Creaci√≥n impl√≠cita de un DAG de extracci√≥n
- Ejecuci√≥n en paralelo de tareas independientes

### ¬øQu√© es Retrieval-Augmented Generation (RAG)?

**RAG** es un enfoque que combina modelos de lenguaje (LLMs) con bases de conocimiento externas, permiti√©ndoles consultar datos din√°micamente en tiempo real.

#### **Objetivos de RAG**:

- **Reducir alucinaciones**: Respuestas basadas en hechos verificables.
- **Incluir conocimiento actualizado y espec√≠fico del dominio**.
- **Aumentar la transparencia**: Capacidad de citar fuentes utilizadas.

#### **Flujo Offline: Preparaci√≥n del Conocimiento**

Proceso previo a recibir preguntas de usuarios. Se construye una base de datos vectorial a partir de documentos crudos.

Etapas:
1. **Load** ‚Äì Se usan *Document Loaders* para cargar documentos desde PDFs, webs, bases de datos, etc.
2. **Split** ‚Äì Los documentos se dividen en *chunks* peque√±os para ajustarse al contexto limitado del LLM.
3. **Embed** ‚Äì Cada chunk se convierte en un vector usando modelos de embeddings (OpenAI, Cohere, etc.).
4. **Store** ‚Äì Los vectores y su texto original se almacenan en bases vectoriales como Qdrant o ChromaDB.

#### **Flujo Online: Generaci√≥n en Tiempo Real**

Se activa cuando un usuario realiza una pregunta. Se recupera informaci√≥n relevante y se genera una respuesta fundamentada.

Etapas:
1. **Retrieve** ‚Äì La pregunta se vectoriza y se buscan los chunks m√°s cercanos en la base vectorial.
2. **Augment** ‚Äì Se crea un *prompt aumentado* que incluye la pregunta y los chunks recuperados.
3. **Generate** ‚Äì El LLM responde usando este prompt enriquecido con contexto f√°ctico.

#### **Limitaci√≥n: Compresi√≥n con P√©rdidas**

El paso de *chunking* puede romper la coherencia entre conceptos relacionados distribuidos en distintas partes del documento.

Ejemplo de Problema:

- Un concepto clave (T√©rmino A) aparece en la p√°gina 1.
- Su aplicaci√≥n (Ejemplo B) aparece en la p√°gina 10.
- RAG puede recuperar solo uno de los dos chunks, generando respuestas incompletas.

### ¬øQu√© es Cognee?

**Cognee** es un framework de c√≥digo abierto para agentes de IA que va m√°s all√° de la b√∫squeda por similitud. Su objetivo es construir una **memoria sem√°ntica evolutiva**, modelando activamente las relaciones entre conceptos mediante grafos de conocimiento y pipelines de datos automatizados.

#### **Pipeline ECL: Extract, Cognify, Load**

Una nueva alternativa al cl√°sico ETL y al flujo de RAG.

1. Extract

- Ingesta de m√∫ltiples fuentes (documentos, bases de datos, transcripciones).
- Utiliza frameworks como `dlt` para conectar m√°s de 28 tipos de fuentes.

2. Cognify

- Paso clave del framework.
- Construye una representaci√≥n dual:
  - **Grafo de conocimiento** (con nodos y relaciones)
  - **√çndice vectorial** para b√∫squeda sem√°ntica
- Detecta entidades, relaciones y dependencias.
- Transforma documentos en mapas conceptuales interactivos.

3. Load

- Persistencia flexible en:
  - Bases de datos vectoriales (Qdrant, Weaviate, etc.)
  - Bases de datos gr√°ficas (Neo4j, NetworkX, etc.)

#### **Ventajas Clave de Cognee**

- **Contexto relacional profundo**: Recupera subgrafos completos, no solo chunks aislados.
- **Razonamiento real**: Permite inferencias l√≥gicas sobre la estructura del conocimiento.
- **Ontolog√≠as personalizadas**: Define esquemas sem√°nticos espec√≠ficos del dominio.
- **Control y privacidad**: Desplegable 100% on-premise.

#### **Casos de Uso**

1. **Asistentes de Programaci√≥n**  
   - Navega y analiza dependencias en bases de c√≥digo complejas.
2. **Chatbots Avanzados y Soporte Contextual**  
   - Construye perfiles de usuario din√°micos basados en historial y preferencias.
3. **Gesti√≥n del Conocimiento y Recursos Humanos**  
   - Extrae respuestas complejas desde grandes vol√∫menes de texto no estructurado.

#### **GraphRAG**

Cognee se alinea con la tendencia de GraphRAG.

### ¬øQu√© son las Bases de Datos Gr√°ficas?

Son sistemas de almacenamiento dise√±ados espec√≠ficamente para **modelar, persistir y consultar relaciones complejas**. A diferencia de las bases relacionales (tablas), las gr√°ficas se estructuran como redes de entidades conectadas.

#### **Modelo de Grafo de Propiedades**

- **Nodos**: Representan entidades (Persona, Empresa, Funci√≥n, etc.)
- **Relaciones**: Conectan nodos, con direcci√≥n y tipo (ej. `LLAMA_A`, `CONOCE`)
- **Propiedades**: Atributos en nodos o relaciones (ej. `nombre: "Alice"`, `desde: 2021`)

Las relaciones son elementos persistentes, no c√°lculos temporales como en los `JOINs` de SQL.

#### **Comparativa: Ventajas y Desventajas**

Ventajas

- **Alto rendimiento** en consultas de m√∫ltiples saltos (traversals)
- **Flexibilidad del esquema** sin migraciones complejas
- **Modelado intuitivo**, alineado con la l√≥gica humana

Desventajas

- **No reemplazan** las bases tradicionales para consultas tabulares masivas
- **Falta de estandarizaci√≥n total** en lenguajes (aunque Cypher es popular)
- **Gesti√≥n compleja** en grafos muy densos o con "supernodos"

#### **Casos de Uso m√°s all√° de RAG**

1. **Detecci√≥n de Fraude**  
   Modelan redes de transacciones, usuarios, IPs y dispositivos para identificar patrones complejos en tiempo real.
2. **Motores de Recomendaci√≥n**  
   Basados en interacciones entre usuarios, productos y preferencias.
3. **Gesti√≥n de Redes de TI**  
   Analizan las dependencias entre servidores, routers y servicios para diagn√≥stico y resiliencia.
4. **Redes Sociales y Grafos de Conocimiento**  
   Usados para an√°lisis de comunidades, propagaci√≥n de informaci√≥n e inferencias sem√°nticas.


#### **Relevancia para IA Cognitiva**

Las bases gr√°ficas son fundamentales para frameworks como **Cognee**, ya que permiten:

- Representar relaciones expl√≠citas entre conceptos
- Recuperar subgrafos como contexto relacional
- Aplicar razonamiento l√≥gico sobre entidades conectadas

Las bases gr√°ficas no solo almacenan datos, **modelan el conocimiento** en su forma m√°s natural y navegable.

### ¬øQu√© es K√πzu?

K√πzu es una base de datos de grafos **open source**, embebida, de alto rendimiento, dise√±ada para tareas anal√≠ticas (OLAP). Su filosof√≠a es similar a la de SQLite, pero en el mundo de los grafos: se ejecuta como una **biblioteca local**, sin servidores ni configuraci√≥n adicional.

#### **Ventajas Clave**

- **Embebido**: se integra directamente como librer√≠a en tu aplicaci√≥n Python (`pip install kuzu`)
- **Optimizado para OLAP**: motor columnar + ejecuci√≥n vectorizada = consultas anal√≠ticas r√°pidas
- **Integraci√≥n con ecosistema Python**: soporta Pandas, Polars, DuckDB, Parquet y Arrow
- **Modelo estructurado**: define tablas de nodos y relaciones con tipos, facilitando optimizaciones


### ¬øQu√© es Neo4j?

Neo4j es una base de datos gr√°fica **nativa, madura y empresarial**, orientada tanto a cargas de trabajo anal√≠ticas (OLAP) como transaccionales (OLTP). Se presenta como una **plataforma completa** para modelar, almacenar y consultar relaciones complejas en entornos de producci√≥n.

#### **Ventajas Clave**

- **Soporte para OLTP y OLAP**  
- **ACID-compliance** para aplicaciones cr√≠ticas  
- **Escalabilidad empresarial** (cl√∫steres, alta disponibilidad)  
- **Graph Data Science (GDS)**: algoritmos de grafos integrados  
- **Comunidad y soporte extensos** (GraphAcademy, documentaci√≥n, partners)  




## üõ†Ô∏è Ejemplo pr√°ctico de K√πzu, Neo4j, Cognee y DLT

### Creaci√≥n de un entorno de desarrollo

Para crear y gestionar el entorno de Python de este proyecto se utiliza `uv`, una herramienta moderna que combina la gesti√≥n de entornos virtuales y la resoluci√≥n de dependencias de forma r√°pida y eficiente.

Este enfoque reemplaza el uso tradicional de herramientas como `venv`, `pip` y `virtualenv`, ofreciendo una experiencia m√°s simple y √°gil.

‚ÑπÔ∏è Para m√°s detalles sobre c√≥mo instalar y utilizar uv, consulta el archivo [`working-with-uv.md`](../docs/working-with-uv.md)

Una vez instalado `uv`, puedes crear el entorno virtual e instalar todas las dependencias necesarias con un solo comando:

```bash
uv venv && uv sync
```

Este comando crear√° un entorno virtual en el directorio del proyecto y sincronizar√° las librer√≠as especificadas en el archivo `pyproject.toml`.

### Ejemplos de uso de grafos y sistemas cognitivos

A continuaci√≥n, se presentan notebooks que exploran el uso de diferentes bases de datos de grafos y sistemas cognitivos aplicados a tareas de an√°lisis y representaci√≥n de conocimiento.


#### **1. Uso de K√πzu para consultas con grafos**

Si deseas ver c√≥mo utilizar la base de datos de grafos **K√πzu** para realizar consultas sobre relaciones complejas, puedes consultar el archivo [`using_kuzu.ipynb`](./notebook/using_kuzu.ipynb).

Este notebook incluye ejemplos de:
- Instalaci√≥n y configuraci√≥n de K√πzu.
- Creaci√≥n de nodos y relaciones.
- Ejecuci√≥n de consultas en lenguaje Cypher.

#### **2. Uso de Neo4j para modelado de grafos**

Para aprender a trabajar con **Neo4j**, una base de datos de grafos ampliamente utilizada en producci√≥n, revisa el archivo [`using_neo4j.ipynb`](./notebook/using_neo4j.ipynb).

Este notebook incluye ejemplos de:
- Conexi√≥n a una instancia local de Neo4j.
- Inserci√≥n de datos con Cypher.
- Ejecuci√≥n de consultas para analizar relaciones.

#### **3. Uso de Cognee como sistema cognitivo basado en grafos**

Si deseas explorar c√≥mo **Cognee** utiliza memoria estructurada y grafos para potenciar la inteligencia artificial, puedes revisar el archivo [`using_cognee.ipynb`](./notebook/using_cognee.ipynb).

Este notebook incluye ejemplos de:
- Inicializaci√≥n y configuraci√≥n de Cognee.
- Inserci√≥n de conocimiento en el grafo cognitivo.
- Consultas y navegaci√≥n por el grafo.
- Integraci√≥n con embeddings y herramientas externas.

#### **4. Integraci√≥n de DLT, Cognee y K√πzu con un dataset real**

Para ver una integraci√≥n pr√°ctica entre **DLT**, **Cognee** y **K√πzu**, puedes consultar el archivo [`dlt_and_cognee_taxi_dataset.ipynb`](./notebook/dlt_and_cognee_taxi_dataset.ipynb).

Este notebook incluye ejemplos de:
- Extracci√≥n y transformaci√≥n de datos con DLT.
- Ingesta del dataset de taxis en un grafo usando K√πzu.
- Enriquecimiento del conocimiento con Cognee.
- An√°lisis y consultas cognitivas sobre datos reales

#### **5. An√°lisis constitucional con Cognee**

Puedes consultar el archivo [`understanding_paraguays_constitution_with_cognee.ipynb`](./notebook/understanding_paraguays_constitution_with_cognee.ipynb), que muestra c√≥mo utilizar **Cognee** para:

- Descargar y procesar el texto completo de la Constituci√≥n Nacional del Paraguay.
- Generar un grafo de conocimiento con entidades y relaciones extra√≠das del documento.
- Realizar b√∫squedas sem√°nticas y consultas cognitivas sobre el contenido constitucional.
- Visualizar las conexiones clave entre conceptos jur√≠dicos utilizando herramientas de grafo.

## üîó Lectura recomendada
Recomendado para profundizar en los conceptos clave y ampliar tu comprensi√≥n

* [dlt - Getting started](https://dlthub.com/docs/intro)
* [dlt - Sourcest](https://dlthub.com/docs/dlt-ecosystem/verified-sources/)
* [dlt - Destinations](https://dlthub.com/docs/dlt-ecosystem/destinations/)
* [dlt - Qdrant destination](https://dlthub.com/docs/dlt-ecosystem/destinations/qdrant)
* [dlt - Code examples](https://dlthub.com/docs/examples)
* [dlt - Using dlt](https://dlthub.com/docs/general-usage)
* [Cognee - Quickstart](https://docs.cognee.ai/quickstart)
* [Cognee - Hello cognee SDK](https://docs.cognee.ai/tutorials/hello-cognee)
* [Cognee - Core Concepts](https://docs.cognee.ai/core-concepts)
* [Cognee - How-to Guides](https://docs.cognee.ai/how-to-guides)
* [Cognee - Colab Notebooks](https://docs.cognee.ai/reference/colab-notebooks)
* [Cognee - Cognee UI](https://docs.cognee.ai/how-to-guides/cognee-ui)
* [Kuzu - Documentation](https://docs.kuzudb.com/)
* [Kuzu - Create your first graph](https://docs.kuzudb.com/get-started/)
* [Kuzu - Python Tutorial: Analyze a Social Network](https://docs.kuzudb.com/tutorials/python/)
* [Kuzu - Python API](https://docs.kuzudb.com/client-apis/python/)
* [Kuzu - Import data](https://docs.kuzudb.com/import/)
* [Cypher - Tutorial](https://docs.kuzudb.com/tutorials/cypher/)
* [Cypher - Manual](https://docs.kuzudb.com/cypher/)
* [Cypher - Run prepared Cypher statements](https://docs.kuzudb.com/get-started/prepared-statements/)
* [Cypher - What is Cypher](https://neo4j.com/docs/getting-started/cypher/)
* [Cypher - Cheat Sheet](https://neo4j.com/docs/cypher-cheat-sheet/5/all/)
* [Neo4j - What is Neo4j?](https://neo4j.com/docs/getting-started/whats-neo4j/)
* [Neo4j - What is a graph database](https://neo4j.com/docs/getting-started/graph-database/)
* [Neo4j - Graph database concepts](https://neo4j.com/docs/getting-started/appendix/graphdb-concepts/)
* [Neo4j - Build applications with Neo4j and Python](https://neo4j.com/docs/python-manual/current/)
* [Neo4j - Neo4j Movies Application](https://github.com/neo4j-examples/movies-python-bolt)
* [Neo4j - The Neo4j Graph Data Science Library Manualxt](https://neo4j.com/docs/graph-data-science/current/)
* [Neo4j - Example datasets](https://neo4j.com/docs/getting-started/appendix/example-data/)
* [Neo4j - Neo4j Tutorial: Using And Querying Graph Databases in Python](https://www.datacamp.com/tutorial/neo4j-tutorial)
* [De la Ingesta de Datos a la Inferencia Cognitiva: Una Arquitectura Moderna con dlt, RAG, Cognee y Bases de Datos Gr√°ficas](https://medium.com/@j92riquelme/de-la-ingesta-de-datos-a-la-inferencia-cognitiva-una-arquitectura-moderna-con-dlt-rag-cognee-e18fdd6e94f8)
* [Dominando Cognee: Estructuraci√≥n de Conocimiento con Pipelines, Ontolog√≠as y el SDK](https://medium.com/@j92riquelme/dominando-cognee-estructuracion-de-conocimiento-con-pipelines-ontologias-y-el-sdk-4ae15fdddb1b)
* [¬øPuede una IA entender la Constituci√≥n del Paraguay? Mi experiencia con¬†Cognee](https://medium.com/@j92riquelme/puede-una-ia-entender-la-constitucion-del-paraguay-mi-experiencia-con-dlt-y-cognee-6715f5708b83)


## ‚ñ∂Ô∏è Videos recomendados
Selecci√≥n de videos para reforzar visualmente los temas abordados

* [What Is A Graph Database? Common features of graph DBMSs.](https://www.youtube.com/watch?v=BksVyv5864k)
* [Cognee GraphRAG + Visualization](https://www.youtube.com/watch?v=1bezuvLwJmw)
* [Host Your Own Local LLM with Ollama & cognee](https://www.youtube.com/watch?v=aZYRo-eXDzA)



## üìö Cursos adicionales recomendados
Recursos complementarios para seguir aprendiendo y fortaleciendo tus habilidades.

* [Graph Data Modeling Fundamentals](https://graphacademy.neo4j.com/courses/modeling-fundamentals/?category=beginners)
* [Cypher Fundamentals](https://graphacademy.neo4j.com/courses/cypher-fundamentals/?category=beginners)
* [Neo4j Fundamentals](https://graphacademy.neo4j.com/courses/neo4j-fundamentals/?category=beginners)
* [Neo4j & GenerativeAI Fundamentals](https://graphacademy.neo4j.com/courses/genai-fundamentals/?category=development)
* [Using Neo4j with Python](https://graphacademy.neo4j.com/courses/drivers-python/?category=development)
* [Build a Neo4j-backed Chatbot using Python](https://graphacademy.neo4j.com/courses/llm-chatbot-python/?category=development)
* [Neo4j Course for Beginners](https://www.youtube.com/watch?v=_IgbB24scLI)

---

> üìå **Nota:** este repositorio complementa el curso **LLM Zoomcamp** de [DataTalks.Club](https://datatalks.club/), y contiene notas, lecturas, videos, ejemplos y recursos adicionales.  
> Para acceder al contenido oficial del curso, visita el [**repositorio principal en GitHub**](https://github.com/DataTalksClub/llm-zoomcamp).
